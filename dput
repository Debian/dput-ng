#! /usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (C) 2012 Arno TÃ¶ll <arno@debian.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

from __future__ import print_function

import libdput.config
import libdput.upload_methods
import libdput.changes
import argparse
import os
import shlex
import time
import sys

from libdput.config import Stanza as opt
from libdput.misc import error, debug, run_command
from libdput.sanitychecks import *


__VERSION__ = "0.1"


parser = argparse.ArgumentParser(description=' Debian package upload tool', epilog="program version %s" % (__VERSION__))
parser.add_argument('-d', '--debug', action='store_true', default=False, help='Enable debug messages')
parser.add_argument('-c', '--config', metavar="FILE", action='store', default=None, help='Configuration file to parse')
parser.add_argument('-D', '--dinstall', action='store_true', help='Run dinstall after upload')
parser.add_argument('-e', '--delayed', action='store', metavar="DAYS", help='Upload to a delayed queue. Takes an argument from 0 to 15', type=int, choices=range(0, 16))
parser.add_argument('-f', '--force', action='store_true', help='Force an upload')
parser.add_argument('-H', '--host-list', action='store_true', help='(ignored)')
parser.add_argument('-l', '--lintian', action='store_true', help='Run lintian before upload')
parser.add_argument('-U', '--no-upload-log', action='store_true', help='Do not write a .upload file after uploading')
parser.add_argument('-o', '--check-only', action='store_true', help='Only check the package')
parser.add_argument('-p', '--print', action='store_true', help='(ignored)')
parser.add_argument('-P', '--passive', action='store_true', help='Use passive mode for ftp uploads')
parser.add_argument('-s', '--simulate', action='store_true', help='Simulate the upload only')
parser.add_argument('-u', '--unchecked', action='store_true', help='Don\'t check GnuPG signature')
parser.add_argument('-v', '--version', action='store_true', help='(ignored)')
parser.add_argument('-V', '--check-version', action='store_true', help='(ignored)')

parser.add_argument('host', metavar="HOST", action='store', default=None, help="Target host to upload a package", nargs="?")
parser.add_argument('changes', metavar="CHANGES-FILE", action='store', default=None, help="A Debian .changes file")
args = parser.parse_args()

def error_unless_forced(argument):
	global args
	if args.force:
		func = warning
	else:
		func = error
	func(argument)

config = libdput.config.Configurator(args.debug)
config.load_configuration(args.config)

stanza = config.get_upload_target(args.host)


if not os.access(args.changes, os.R_OK):
	error("Changes file %s is not accessible" % (args.changes))
try:
	changes = libdput.changes.Changes(filename=args.changes)
	changes.set_directory(os.path.dirname(args.changes))
	debug("Parsing changes file %s" % (args.changes))
except Exception as e:
	error("Error parsing changes file %s: %s" % (args.changes, e))


upload_file = changes.get_changes_file() + "." + stanza.name() + ".upload"

if os.access(upload_file, os.R_OK) and not args.force and not args.check_only:
	error("Package %s was already uploaded to %s: Aborting\nIf you want to upload nonetheless, use --force or remove %s" % (changes.get_filename(), stanza.name(), upload_file))

# check files for their existence in advance
for filename in changes.get_files():
	if not os.access(filename, os.R_OK):
		error("Referenced file %s is not accessible" % (filename))

try:
	# check signature and file integrity
	check_signature = not stanza[opt.KEY_ALLOW_UNSIGNED_UPLOADS] and not args.unchecked
	changes.validate(stanza[opt.KEY_HASH], check_signature)
except libdput.changes.ChangesFileException as e:
	error_unless_forced("Changes file %s is invalid: %s" % (changes.get_filename(), e))

try:
	# check mismatch between Distribution and Changes in *.changes
	check_distribution(changes)

	# check whether -sa was missing when building the changes files
	check_source_needed(changes)

	if stanza[opt.KEY_RUN_LINTIAN] or args.lintian:
		# run lintian
		run_lintian(changes.get_changes_file())

	# run piuparts
	run_piuparts(changes.get_changes_file())
except SanityException as e:
	error_unless_forced("Upload fails sanity check: %s" % (e))

# run pre upload commands
if stanza[opt.KEY_PRE_UPLOAD_COMMAND]:
	(cmd_out, cmd_err, _) = run_command(shlex.split(stanza[opt.KEY_PRE_UPLOAD_COMMAND]))
	print(cmd_out)
	print(cmd_err)

# special care for DELAYED uploads
if args.delayed:
	debug("overriding upload directory to respect --delayed")
	incoming_directory = os.path.join(stanza[opt.KEY_INCOMING], "DELAYED", "%d-day" % (args.delayed))
	stanza[opt.KEY_INCOMING] = incoming_directory


#raise Exception("barrier")

# ftp|http|httpd|scp|rsync|local
upload_method = stanza[opt.KEY_METHOD].lower()
upload = None


if  not args.check_only:
	print("Uploading %s to %s (%s)" % (changes.get_filename(), stanza[opt.KEY_FQDN], stanza[opt.KEY_INCOMING]))
	if upload_method == 'ftp':
		debug("Using FTP upload method")
		upload = libdput.upload_methods.FTPUpload(stanza)
	elif upload_method == 'http':
		debug("Using HTTP upload method")
		upload = libdput.upload_methods.HTTPUpload(stanza)
	elif upload_method == 'https':
		debug("Using HTTPS upload method")
		upload = libdput.upload_methods.HTTPSUpload(stanza)
	elif upload_method == 'sftp':
		debug("Using SFTP upload method")
		upload = libdput.upload_methods.SFTPUpload(stanza)
	else:
		error("Unknown upload method: %s" % (upload_method))

	upload.initialize(passive_mode=args.passive)
	for filename in changes.get_files() + [changes.get_changes_file(), ]:
		print("Uploading %s ..." % (filename))
		if not args.simulate:
			upload.upload_file(filename)
		else:
			print ("(not uploading: dry-run)")
	upload.shutdown()

if stanza[opt.KEY_RUN_DINSTALL] or args.dinstall:
	# run dinstall
	run_dinstall()


# run post upload commands
if stanza[opt.KEY_POST_UPLOAD_COMMAND]:
	(cmd_out, cmd_err, _) = run_command(shlex.split(stanza[opt.KEY_POST_UPLOAD_COMMAND]))
	print(cmd_out)
	print(cmd_err)

# write the logfile
if not args.no_upload_log and not args.check_only:
	if os.access(upload_file, os.F_OK):
		error("Couldn't write log file %s: File already exists" % (upload_file))
	try:
		ufh = open(upload_file, "w")
		ufh.write("method: %s\nhost: %s\n" % (stanza[opt.KEY_METHOD], stanza[opt.KEY_FQDN]))
		for filename in changes.get_files() + [changes.get_changes_file(), ]:
			ufh.write("uploaded: %s\n" % (filename))
		ufh.write("uploader: %s\n" % (os.getlogin()))
		ufh.write("timestamp: %s\n" % (time.time()))
		if args.simulate:
			ufh.write("dry-run: yes\n")
		ufh.close()
	except OSError as e:
		error("Couldn't write log file %s: %s" % (upload_file, e))
