#!/usr/bin/env python
# D.I.R.T.

# arguments:
#    --blame target
#    --hosts
#    --help-checker
#    --help-processor

import os
import sys
import json
import argparse

# A little temporary hack for those of us not using virtualenv
sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))


from dput.hook import hook_docs
from dput.util import get_configs
from dput.exceptions import DputConfigurationError
from dput.profile import get_blame_map, profiles, load_profile


parser = argparse.ArgumentParser(description='dput information retrieval tool')
group = parser.add_mutually_exclusive_group(required=True)


group.add_argument(
    '--hosts',
    action='store_true',
    help='print the lists of hosts that dput knows about'
)

group.add_argument(
    '--remove-hook',
    nargs=2,
    action='store',
    help='print the lists of hosts that dput knows about'
)

group.add_argument(
    '--add-hook',
    nargs=2,
    action='store',
    help='print the lists of hosts that dput knows about'
)

group.add_argument(
    '--blame',
    action='store',
    help='get information on where dput is finding keys'
)

group.add_argument(
    '--list',
    action='store_true',
    help='list all the hooks'
)

group.add_argument(
    '--info',
    action='store',
    help='get some help on a hook'
)

args = parser.parse_args()

if args.blame:
    if args.blame not in profiles():
        print "No such target."
        sys.exit(1)

    print json.dumps(get_blame_map(args.blame), sort_keys=True, indent=4)
    sys.exit(0)

if args.hosts:
    default = load_profile(None)
    print
    print "Default method: %s" % (default['method'])
    print
    for config in profiles():
        obj = load_profile("%s:%s" % (config, config))
        #                               ^^^^^^ fake arg for others
        if not "fqdn" in obj:  # likely localhost
            obj['fqdn'] = 'localhost'

        string = "{name} => {fqdn}  (Upload method: {method})".format(**obj)
        print string
    print
    sys.exit(0)


if args.info:
    try:
        docs = hook_docs(args.info)
        if docs == "":
            print "Sorry, the author didn't provide help on this module."
            sys.exit(0)
        print docs
    except DputConfigurationError:
        print "No such hook '%s'." % (args.info)
        sys.exit(1)


if args.list:
    for config in get_configs('hooks'):
        print config
    sys.exit(0)

# Dear lord of all that is holy, the kruft below *needs* to be moved into
# proper dput config objects. We should really just grab the local foo, and
# deal with that mess on the fly. Don't put it there until it's factored in
# nicely.
#   - PRT

def _read_file(fpath):
    obj = {}
    if os.path.exists(fpath):
        obj = json.load(open(fpath, 'r'))
    return obj

def _write_file(fpath, obj):
    d = os.path.dirname(fpath)
    if not os.path.exists(d):
        os.makedirs(d)
    open(fpath, 'w').write(json.dumps(obj, sort_keys=True, indent=4))

if args.add_hook:
    hook, target = args.add_hook
    # sanity check target, now.
    # sanity check hook, now.
    config = os.path.expanduser(
        "~/.dput.d/profiles/%s.json" % (target)  # XXX: Do this right.
    )
    obj = _read_file(config)
    if not '+hooks' in obj:
        obj['+hooks'] = []
    if hook not in obj['+hooks']:
        print "Added %s to the config." % (hook)
        obj['+hooks'].append(hook)
    else:
        print "%s is already in the config." % (hook)

    _write_file(config, obj)
    sys.exit(0)


if args.remove_hook:
    hook, target = args.remove_hook
    # sanity check target, now.
    # sanity check hook, now.
    config = os.path.expanduser(
        "~/.dput.d/profiles/%s.json" % (target)  # XXX: Do this right.
    )
    obj = _read_file(config)

    if 'hooks' in obj:
        if hook in obj['hooks']:
            obj['hooks'].remove(hook)

    elif '+hooks' in obj:
        if hook in obj['+hooks']:
            obj['+hooks'].remove(hook)
    else:
        if not '-hooks' in obj:
            obj['-hooks'] = []

        obj['-hooks'].append(hook)

    _write_file(config, obj)
    sys.exit(0)
